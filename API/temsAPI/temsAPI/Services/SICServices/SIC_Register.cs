using Microsoft.EntityFrameworkCore;
using SIC_Parser.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using temsAPI.Contracts;
using temsAPI.Data.Entities.EquipmentEntities;

namespace temsAPI.Services.SICServices
{
    internal class SIC_Register
    {
        readonly IUnitOfWork _unitOfWork;
        readonly SICValidator _sicValidator;

        public SIC_Register(IUnitOfWork unitOfWork, SICValidator sicValidator)
        {
            _unitOfWork = unitOfWork;
            _sicValidator = sicValidator;
        }

        /// <summary>
        /// Registers a computer based on data being provided by the model (sicComputer)
        /// </summary>
        /// <param name="unitOfWork"></param>
        /// <param name="sicComputer">Computer model generated by SIC Parser</param>
        /// <returns>Returns null if everything is ok, otherwise - error message.</returns>
        public async Task<string> RegisterComputer(Computer sicComputer)
        {
            // Process of registering a computer:
            // 1) Create an equipment with name Computer. Set ID.
            // 2) Find out if computer definition exists. If not - create it.
            // 2.1) How to create a computer definition?
            //      Create a definition with the specified identifier.
            //      Foreach sicComputer child, if not null, check if child definition exists, if so => set it.
            //      Otherwise - create the definition and set it.
            //      Add the definition as child for computer definition.
            //      Save definition.
            // 3) Register the equipment itsels by providing temsid and serial numbers.
            //      Computer serial number is motherboard serial number.
            //      then, foreach children, do the following:
            //      a. check if there is a serialNumber property. If so,
            //      check if there isn't any equipment with the same id already registered.
            //      if there is >>
            //         Add [Type]_[index]_[serialNumber] as serial number
            //      if there isn't >> set the serial number.
            //   Add description for types that have this property
            //   Description for computer will be TV data.

            // Validate the model iteslf
            string validationResult = sicComputer.Validate();
            if (validationResult != null)
                return validationResult;

            sicComputer.AssignIndexes();

            validationResult = await _sicValidator.ValidateAgainstUnitOfWork(sicComputer);
            if (validationResult != null)
                return validationResult;

            var computerType = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(
                    where: q => q.Name == "Computer",
                    include: q => q.Include(q => q.EquipmentDefinitions)
                    )).FirstOrDefault();

            var computerDefinition = computerType.EquipmentDefinitions
                .FirstOrDefault(q => q.Identifier == sicComputer.Identifier);

            var computer = new Equipment
            {
                Id = Guid.NewGuid().ToString(),
                TEMSID = sicComputer.TEMSID,
                IsUsed = sicComputer.IsUsed,
                IsDefect = sicComputer.IsDefect,
                RegisterDate = DateTime.Now
            };

            if(!String.IsNullOrEmpty(sicComputer.TeamViewerID) && !String.IsNullOrEmpty(sicComputer.TeamViewerPassword))
            {
                computer.Description = String.Format(
                    "Team Viewer ID: [ {0} ], {1}Team Viewer Password: [ {2} ], {3} {4}", 
                    sicComputer.TeamViewerID, 
                    Environment.NewLine,
                    sicComputer.TeamViewerPassword,
                    Environment.NewLine,
                    sicComputer.Description);
            }

            if (computerDefinition != null)
                computer.EquipmentDefinition = computerDefinition;
            else
                computer.EquipmentDefinition = await RegisterComputerDefinition(sicComputer);

            await _unitOfWork.Save();
                
            await AssignData(computer, sicComputer);

            await _unitOfWork.Equipments.Create(computer);
            await _unitOfWork.Save();

            // BEFREE: TEST & ADD MORE VALIDATION
            return null;
        }

        /// <summary>
        /// Registers a new computer definition, based on info provided by sicCoputer model.
        /// </summary>
        /// <param name="sicComputer"></param>
        /// <returns>The equipment definition that has been created</returns>
        private async Task<EquipmentDefinition> RegisterComputerDefinition(Computer sicComputer)
        {
            var type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "Computer"))
                .FirstOrDefault();

            EquipmentDefinition computerDefinition = new EquipmentDefinition
            {
                Id = Guid.NewGuid().ToString(),
                Identifier = sicComputer.Identifier,
                EquipmentType = type
            };

            await _unitOfWork.EquipmentDefinitions.Create(computerDefinition);
            await _unitOfWork.Save();

            // CPU Definitions
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "CPU"))
                .FirstOrDefault();
            foreach (var cpu in sicComputer.CPUs)
                await AddChildDefinition(cpu, "Name", computerDefinition, type);

            // GPU Definitions
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "GPU"))
                .FirstOrDefault();
            foreach (var gpu in sicComputer.GPUs)
                await AddChildDefinition(gpu, "Name", computerDefinition, type);

            // PSUs
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "PSU"))
                .FirstOrDefault();
            foreach (var psu in sicComputer.PSUs)
            {
                if (String.IsNullOrEmpty(psu.SerialNumber))
                    continue;
                
                await AddChildDefinition(psu, "Model", computerDefinition, type);
            }

            // Motherboards
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "Motherboard"))
                .FirstOrDefault();
            foreach (var motherboard in sicComputer.Motherboards)
                await AddChildDefinition(motherboard, "Product", computerDefinition, type);

            // NetworkInterfaces
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "Network Interface"))
                .FirstOrDefault();
            foreach (var netIntf in sicComputer.NetworkInterfaces)
                await AddChildDefinition(netIntf, "Description", computerDefinition, type);

            // Monitors
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "Monitor"))
                .FirstOrDefault();
            foreach (var monitor in sicComputer.Monitors)
            {
                if (String.IsNullOrEmpty(monitor.SerialNumber) && String.IsNullOrEmpty(monitor.TEMSID))
                    continue;

                await AddChildDefinition(monitor, "Name", computerDefinition, type);
            }

            // RAMS
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "RAM"))
                .FirstOrDefault();
            foreach (var ram in sicComputer.RAMs)
                await AddChildDefinition(ram, "PartNumber", computerDefinition, type);

            // Storages
            type = (await _unitOfWork.EquipmentTypes
                .Find<EquipmentType>(q => q.Name == "Storage"))
                .FirstOrDefault();
            foreach (var storage in sicComputer.Storages)
                await AddChildDefinition(storage, "Caption", computerDefinition, type);

            await _unitOfWork.Save();
            return computerDefinition;
        }

        /// <summary>
        /// Given an instance of Equipment (computer) and the sicComputer model, it assigns data from
        /// sicComputer to Equipment instance.
        /// </summary>
        /// <param name="computer"></param>
        /// <param name="sicComputer"></param>
        /// <returns></returns>
        private async Task AssignData(Equipment computer, Computer sicComputer)
        {
            IEnumerable<ITEMSIndexable> children = sicComputer.CPUs
                .Concat<ITEMSIndexable>(sicComputer.GPUs)
                .Concat(sicComputer.PSUs)
                .Concat(sicComputer.Motherboards)
                .Concat(sicComputer.Monitors)
                .Concat(sicComputer.NetworkInterfaces)
                .Concat(sicComputer.RAMs)
                .Concat(sicComputer.Storages);

            foreach(var item in children)
            {
                await AssignChildData(item, computer);
            }
        }

        /// <summary>
        /// Assigns data from sicEntity (child equipment, like GPU, CPU etc.) to the parent, which is the 
        /// Equipment instance of computer (parent).
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="entity">SIC child model</param>
        /// <param name="identifierPropName">Name of the property which identifies child model's definition</param>
        /// <param name="parent">Equipment instance, representing the computer</param>
        /// <param name="serialNumber">The serial number that will be assigned to child</param>
        /// <param name="TEMSID">(Optional) - child temsId (if it exists)</param>
        /// <returns></returns>
        private async Task AssignChildData(ITEMSIndexable entity, Equipment parent)
        {
            var entityProperties = entity.GetType().GetProperties();
            var identifierValue = entityProperties.Where(q => q.Name == entity.IdentifierPropertyName)
                .FirstOrDefault()
                .GetValue(entity)
                .ToString();

            var definition = (await _unitOfWork.EquipmentDefinitions
                    .Find<EquipmentDefinition>(q => q.Identifier == identifierValue))
                    .FirstOrDefault();

            var childEquipment = new Equipment()
            {
                Id = Guid.NewGuid().ToString(),
                SerialNumber = entity.TEMSSerialNumber,
                EquipmentDefinition = definition
            };

            var temsIdProp = entityProperties.FirstOrDefault(q => q.Name.ToLower() == "temsid");
            if (temsIdProp != null)
                childEquipment.TEMSID = temsIdProp.GetValue(entity).ToString();

            parent.Children.Add(childEquipment);
        }

        /// <summary>
        /// Adds from existing or creates a new definition for child equipment.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="entity">SIC child model</param>
        /// <param name="identifierPropName">Name of the property which identifies child model's definition</param>
        /// <param name="parentDefinition">computer's definition</param>
        /// <returns></returns>
        private async Task AddChildDefinition<T>(T entity, string identifierPropName, EquipmentDefinition parentDefinition, EquipmentType type)
        {
            string identifierValue = entity.GetType().GetProperty(identifierPropName).GetValue(entity).ToString();
            EquipmentDefinition def = (await _unitOfWork.EquipmentDefinitions
                    .Find<EquipmentDefinition>(q => q.Identifier == identifierValue))
                    .FirstOrDefault();

            if (def != null)
            {
                parentDefinition.Children.Add(def);
                return;
            }

            def = new EquipmentDefinition
            {
                Id = Guid.NewGuid().ToString(),
                Identifier = identifierValue,
                Parent = parentDefinition,
                EquipmentType = type
            };

            await AddDefinitionSpecifications(def, entity);
            await _unitOfWork.EquipmentDefinitions.Create(def);
            await _unitOfWork.Save();
        }

        /// <summary>
        /// Adds definition specifications (property-value associations) based on the provided
        /// entity.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="definition">Definition to be modified</param>
        /// <param name="entity">SIC Child model</param>
        /// <returns></returns>
        private async Task AddDefinitionSpecifications<T>(EquipmentDefinition definition, T entity)
        {
            foreach (var prop in entity.GetType().GetProperties())
            {
                var property = (await _unitOfWork.Properties
                    .Find<Property>(
                        where: q => q.Name == prop.Name,
                        include: q => q.Include(q => q.DataType)
                    )).FirstOrDefault();

                if (property == null)
                    continue;

                definition.EquipmentSpecifications.Add(new EquipmentSpecifications
                {
                    Id = Guid.NewGuid().ToString(),
                    EquipmentDefinition = definition,
                    Property = property,
                    Value = prop.GetValue(entity).ToString(),
                });
            }
        }
    }
}
